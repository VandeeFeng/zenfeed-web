<script lang="ts">
    import { onMount, tick, onDestroy, afterUpdate } from "svelte"; // Added beforeUpdate, afterUpdate
    import { marked } from "marked";
    import { fly } from "svelte/transition";
    import { cubicOut } from "svelte/easing";
    import { _ } from "svelte-i18n";
    import { getTargetApiUrl } from "$lib/utils/apiUtils";
    import { env } from "$env/dynamic/public";
    import { goto } from "$app/navigation";
    import { selectedFeedStore, queryFeedsStore } from "$lib/stores/feedStore"; // Renamed import to avoid conflict
    import { get } from "svelte/store";
    const disableAddSource = env.PUBLIC_DISABLE_ADD_SOURCE === "true";
    const disableSearchTerm = env.PUBLIC_DISABLE_SEARCH_TERM === "true";

    interface FeedLabel {
        [key: string]: string;
    }

    interface FeedVO {
        labels: FeedLabel;
        time: string; // Comes as string, parse for sorting
        // Add a unique ID property generated by getFeedItemId
        id?: string;
    }

    interface QueryResponse {
        summary: string;
        feeds: FeedVO[];
        count: number;
    }

    interface GroupedFeeds {
        [source: string]: FeedVO[];
    }

    // --- Constants ---
    const READ_ITEMS_STORAGE_KEY = "zenfeed_read_feeds";
    const GROUP_BY_LABEL_STORAGE_KEY = "zenfeed_group_by_label";
    const ACTIVE_GROUP_NAME_STORAGE_KEY = "zenfeed_active_group_name"; // New Key for active tab
    const SCROLL_POSITION_STORAGE_KEY = "zenfeed_scroll_position"; // Key for scroll position
    const NAVIGATING_TO_DETAIL_KEY = "zenfeed_navigating_to_detail"; // NEW: Key for navigation flag
    const DEFAULT_GROUP_BY_LABEL =
        env.PUBLIC_DEFAULT_GROUP_BY_LABEL || "source";
    const FEED_TITLE_PREFIX_LABEL = env.PUBLIC_FEED_TITLE_PREFIX_LABEL;
    const MARK_ON_MOBILE_KEY = "zenfeed_markFeedIdOnMobile";

    // --- Types ---
    type ReadItemsMap = Map<string, number>; // Map<itemId, timestamp>

    // --- Component State ---
    let searchTerm = "";
    let searchResults: QueryResponse | null = null;
    let groupedFeeds: GroupedFeeds = {};
    let isLoading = false;
    let availableGroupByLabels: string[] = [DEFAULT_GROUP_BY_LABEL];
    let selectedGroupByLabel = DEFAULT_GROUP_BY_LABEL;
    let error: string | null = null;
    let readItems: ReadItemsMap = new Map();
    let markAsReadSound: HTMLAudioElement | null = null;
    let isMobile = false;
    let shouldRestoreScroll = false; // Flag to indicate scroll restoration is needed
    let itemIdToMarkOnReturn: string | null = null; // Store ID to mark after returning

    // --- NEW State for Desktop Layout ---
    let initialActiveGroupName: string | null = null; // Store loaded group name temporarily
    let activeGroupName: string | null = null; // Currently selected group tab (desktop)
    let selectedFeedDesktop: FeedVO | null = null; // Feed selected for detail view (desktop)
    let rightPanelHtml = ""; // Parsed HTML for the right panel
    let detailPanelContentElement: HTMLDivElement | null = null; // NEW: Reference to the detail panel's scrollable content area

    // --- Reactive Derived State ---

    // Add unique IDs to feeds (only needs to happen once after fetch)
    let feedsWithIds: FeedVO[] = [];
    $: if (searchResults?.feeds) {
        feedsWithIds = searchResults.feeds.map((feed) => ({
            ...feed,
            id: getFeedItemId(feed),
        }));
        // Re-group feeds with IDs whenever results or group label changes
        groupFeeds(feedsWithIds, selectedGroupByLabel);
    }

    // Filter out read items (uses feedsWithIds implicitly via groupedFeeds)
    $: filteredGroupedFeeds = filterReadItems(groupedFeeds, readItems);

    // Calculate the count of items marked read today
    $: todayReadCount = calculateTodayReadCount(readItems);

    // Sort the groups alphabetically by group name for tabs/display
    $: sortedGroupEntries = Object.entries(filteredGroupedFeeds).sort((a, b) =>
        a[0].localeCompare(b[0]),
    );

    // Update active tab and select first feed if needed
    $: {
        if (sortedGroupEntries.length > 0 && !isLoading) {
            const currentGroupNames = sortedGroupEntries.map(
                (entry) => entry[0],
            );
            let newActiveGroupName: string | null = null; // Use temporary variable
            let groupChanged = false; // Flag to track if the active group changed

            // 1. Try to restore initial active group name from localStorage first
            if (
                initialActiveGroupName &&
                currentGroupNames.includes(initialActiveGroupName)
            ) {
                newActiveGroupName = initialActiveGroupName;
                initialActiveGroupName = null; // Mark as used
                if (newActiveGroupName !== activeGroupName) {
                    groupChanged = true;
                }
            } else {
                // 2. If initial restore failed or wasn't applicable, check current active group validity
                if (
                    activeGroupName &&
                    currentGroupNames.includes(activeGroupName)
                ) {
                    newActiveGroupName = activeGroupName; // Keep current active group
                } else {
                    // 3. If current is also invalid or null, select the first available group
                    newActiveGroupName = currentGroupNames[0];
                    groupChanged = true; // Group definitely changed or initialized
                }
            }

            // 4. Update active group name if it actually changed (saving is now handled in a separate block)
            if (newActiveGroupName !== activeGroupName) {
                activeGroupName = newActiveGroupName;
            }

            // 5. Determine the feeds for the active group
            const currentGroupFeeds = activeGroupName
                ? filteredGroupedFeeds[activeGroupName]
                : [];

            // 6. Update the selected feed
            if (groupChanged) {
                selectedFeedDesktop =
                    currentGroupFeeds && currentGroupFeeds.length > 0
                        ? currentGroupFeeds[0]
                        : null;
            } else if (currentGroupFeeds && currentGroupFeeds.length > 0) {
                const selectedFeedStillExists =
                    selectedFeedDesktop &&
                    currentGroupFeeds.some(
                        (feed) => feed.id === selectedFeedDesktop!.id,
                    );
                if (!selectedFeedStillExists) {
                    selectedFeedDesktop = currentGroupFeeds[0];
                }
            } else {
                selectedFeedDesktop = null;
            }
        } else if (!isLoading) {
            // No groups available or loading finished with no groups
            if (activeGroupName !== null) {
                // Only update if it changes to null
                activeGroupName = null;
                selectedFeedDesktop = null;
                // Removal from storage is handled in the dedicated saving block below
            }
        }
        // Dependencies: sortedGroupEntries, isLoading, filteredGroupedFeeds
        // Indirect dependencies: selectedFeedDesktop (read), activeGroupName (read/write), initialActiveGroupName (read)
    }

    // Reactive variable for main search summary HTML
    let summaryHtml = "";
    $: summaryHtml = searchResults?.summary
        ? (marked.parse(searchResults.summary) as string)
        : "";

    // Reactive variable for the right panel detail view HTML
    $: rightPanelHtml = selectedFeedDesktop?.labels?.summary_html_snippet
        ? (marked.parse(
              selectedFeedDesktop.labels.summary_html_snippet,
          ) as string)
        : "";

    // NEW: Reset scroll position of the detail panel when the selected feed changes
    $: if (detailPanelContentElement && selectedFeedDesktop) {
        // Checking selectedFeedDesktop ensures this runs when a feed is selected
        // (or changes), not just on initial mount if the element exists but no feed is selected yet.
        detailPanelContentElement.scrollTop = 0;
    }

    // --- Utility Functions ---

    function simpleHash(str: string): number {
        let hash = 5381;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) + hash + char;
        }
        return hash >>> 0;
    }

    function getFeedItemId(feed: FeedVO): string {
        // Use pre-calculated ID if available
        if (feed.id) return feed.id;
        // Calculate otherwise (should only happen if accessed before `feedsWithIds` is set)
        const labels = feed.labels;
        const sortedKeys = Object.keys(labels).sort();
        const combinedString = sortedKeys
            .map((key) => `${key}=${labels[key]}`)
            .join("&");
        const hashValue = simpleHash(combinedString);
        return hashValue.toString();
    }

    function compareFeeds(a: FeedVO, b: FeedVO): number {
        try {
            const timeA = new Date(a.time);
            const timeB = new Date(b.time);
            if (timeA > timeB) return -1;
            if (timeA < timeB) return 1;
            const titleA = a.labels.title || "";
            const titleB = b.labels.title || "";
            return titleA.localeCompare(titleB);
        } catch (e) {
            console.error("Error parsing date during sort:", e, a.time, b.time);
            const titleA = a.labels.title || "";
            const titleB = b.labels.title || "";
            return titleA.localeCompare(titleB);
        }
    }

    function isToday(timestamp: number): boolean {
        const now = new Date();
        const dateFromTimestamp = new Date(timestamp);
        return (
            dateFromTimestamp.getDate() === now.getDate() &&
            dateFromTimestamp.getMonth() === now.getMonth() &&
            dateFromTimestamp.getFullYear() === now.getFullYear()
        );
    }

    function calculateTodayReadCount(items: ReadItemsMap): number {
        let count = 0;
        for (const timestamp of items.values()) {
            if (isToday(timestamp)) {
                count++;
            }
        }
        return count;
    }

    function filterReadItems(
        groups: GroupedFeeds,
        readItemsMap: ReadItemsMap,
    ): GroupedFeeds {
        const filteredGroups: GroupedFeeds = {};
        for (const source in groups) {
            const unreadFeeds = groups[source].filter(
                (feed) => !readItemsMap.has(feed.id!), // Use pre-calculated ID
            );
            if (unreadFeeds.length > 0) {
                filteredGroups[source] = unreadFeeds;
            }
        }
        return filteredGroups;
    }

    // --- NEW Function to prevent scroll chaining ---
    function preventScrollChaining(event: WheelEvent) {
        const element = event.currentTarget as HTMLElement;
        const { scrollTop, scrollHeight, clientHeight } = element;
        const deltaY = event.deltaY; // Get deltaY from the event

        // Only prevent if the element is actually scrollable
        if (scrollHeight <= clientHeight) {
            return;
        }

        // Prevent scrolling up when already at the top
        if (scrollTop === 0 && deltaY < 0) {
            event.preventDefault();
        }

        // Prevent scrolling down when already at the bottom
        // Use a small tolerance (e.g., 1px) for potential floating point inaccuracies
        if (scrollTop + clientHeight >= scrollHeight - 1 && deltaY > 0) {
            event.preventDefault();
        }
    }

    // --- Data Fetching & Processing ---

    async function fetchFeeds() {
        isLoading = true;
        error = null;
        searchResults = null;
        groupedFeeds = {};
        feedsWithIds = []; // Reset derived state
        selectedFeedDesktop = null; // Reset selection

        try {
            const now = new Date();
            const past24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);

            const response = await fetch(getTargetApiUrl("/query"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    start: past24h.toISOString(),
                    end: now.toISOString(),
                    limit: 500,
                    query: searchTerm,
                    summarize: !!searchTerm,
                }),
            });

            if (!response.ok) {
                const errorText = await response.text();
                let detail = errorText;
                try {
                    const jsonError = JSON.parse(errorText);
                    detail = jsonError.message || jsonError.error || errorText;
                } catch (_) {
                    /* Ignore */
                }
                throw new Error(
                    $_("past24h.errorApi", {
                        values: { status: response.status, detail: detail },
                    }),
                );
            }

            const data: QueryResponse = await response.json();
            queryFeedsStore.set(data); // NEW: Update the store with fetched data
            searchResults = data; // Update local state (triggers reactive updates)
            updateAvailableLabels(data.feeds);

            // Check for scroll restoration *after* fetch success (if not returning from detail)
            const isReturning =
                sessionStorage.getItem(NAVIGATING_TO_DETAIL_KEY) === "true";
            if (
                !isReturning &&
                typeof sessionStorage !== "undefined" &&
                isMobile
            ) {
                const savedScroll = sessionStorage.getItem(
                    SCROLL_POSITION_STORAGE_KEY,
                );
                if (savedScroll) {
                    shouldRestoreScroll = true;
                }
            }
        } catch (e: any) {
            console.error("Failed to fetch feeds:", e);
            error = e.message || $_("past24h.errorLoadingDefault");
            searchResults = null; // Clear results on error
            queryFeedsStore.set(null); // Clear cache on error
            itemIdToMarkOnReturn = null;
        } finally {
            isLoading = false;
        }
    }

    function updateAvailableLabels(feeds: FeedVO[]) {
        const allLabels = new Set<string>([DEFAULT_GROUP_BY_LABEL]);
        const labelValueCounts: { [key: string]: { [value: string]: number } } =
            {};

        feeds.forEach((feed) => {
            Object.keys(feed.labels).forEach((labelKey) => {
                if (
                    labelKey === "link" ||
                    labelKey === "title" ||
                    labelKey === "summary_html_snippet"
                )
                    return;
                allLabels.add(labelKey);
                const labelValue =
                    feed.labels[labelKey] || $_("past24h.uncategorizedGroup");
                if (!labelValueCounts[labelKey])
                    labelValueCounts[labelKey] = {};
                labelValueCounts[labelKey][labelValue] =
                    (labelValueCounts[labelKey][labelValue] || 0) + 1;
            });
        });

        const usefulLabels = Array.from(allLabels).filter((labelKey) => {
            if (labelKey === DEFAULT_GROUP_BY_LABEL) return true;
            const counts = labelValueCounts[labelKey];
            if (!counts) return false;
            return Object.values(counts).some((count) => count > 1);
        });

        availableGroupByLabels = usefulLabels.sort();

        if (!availableGroupByLabels.includes(selectedGroupByLabel)) {
            console.warn(
                `Selected group label "${selectedGroupByLabel}" no longer valid. Resetting to "${DEFAULT_GROUP_BY_LABEL}".`,
            );
            selectedGroupByLabel = DEFAULT_GROUP_BY_LABEL;
            // Save the reset value directly
            if (typeof localStorage !== "undefined") {
                try {
                    localStorage.setItem(
                        GROUP_BY_LABEL_STORAGE_KEY,
                        selectedGroupByLabel,
                    );
                } catch (e) {
                    console.error(
                        "Failed to save reset group by preference:",
                        e,
                    );
                }
            }
        }
    }

    function groupFeeds(feeds: FeedVO[], groupByKey: string) {
        const groups: GroupedFeeds = {};
        feeds.forEach((feed) => {
            const groupValue =
                feed.labels[groupByKey] || $_("past24h.uncategorizedGroup");
            if (!groups[groupValue]) groups[groupValue] = [];
            groups[groupValue].push(feed);
        });

        for (const groupValue in groups) {
            groups[groupValue].sort(compareFeeds);
        }
        groupedFeeds = groups; // Update the base grouped feeds
    }

    // NEW: Reactive block specifically for saving activeGroupName
    $: {
        if (typeof localStorage !== "undefined") {
            try {
                if (activeGroupName) {
                    localStorage.setItem(
                        ACTIVE_GROUP_NAME_STORAGE_KEY,
                        activeGroupName,
                    );
                }
            } catch (e) {
                console.error(
                    "Failed to save active group name preference:",
                    e,
                );
            }
        }
    }

    function handleSearch() {
        if (isLoading) return;
        queryFeedsStore.set(null); // NEW: Clear cache on new search
        fetchFeeds();
    }

    function handleKeydown(event: KeyboardEvent) {
        if (event.key === "Enter") {
            handleSearch();
        }
    }

    // --- Item Interaction Handlers ---

    function markItemRead(itemId: string) {
        const nowTimestamp = Date.now();
        if (!readItems.has(itemId)) {
            if (markAsReadSound) {
                markAsReadSound.currentTime = 0;
                markAsReadSound
                    .play()
                    .catch((error) =>
                        console.warn("Audio playback failed:", error),
                    );
            }
            const updatedReadItems = new Map(readItems); // Create a mutable copy
            updatedReadItems.set(itemId, nowTimestamp);
            readItems = updatedReadItems; // Trigger reactivity for filtering

            // --- Find the next feed to select (Desktop) ---
            let nextSelectedFeed: FeedVO | null = null;
            if (!isMobile && activeGroupName && groupedFeeds[activeGroupName]) {
                // Check if not mobile
                const currentGroupOriginalFeeds = groupedFeeds[activeGroupName];
                const markedIndex = currentGroupOriginalFeeds.findIndex(
                    (feed) => feed.id === itemId,
                );

                if (markedIndex !== -1) {
                    // Try finding the next *unread* item in the current group
                    for (
                        let i = markedIndex + 1;
                        i < currentGroupOriginalFeeds.length;
                        i++
                    ) {
                        const potentialNextFeed = currentGroupOriginalFeeds[i];
                        if (!readItems.has(potentialNextFeed.id!)) {
                            // Check against *updated* readItems
                            nextSelectedFeed = potentialNextFeed;
                            break;
                        }
                    }

                    // If no next unread item, try finding the previous *unread* item
                    if (!nextSelectedFeed) {
                        for (let i = markedIndex - 1; i >= 0; i--) {
                            const potentialPrevFeed =
                                currentGroupOriginalFeeds[i];
                            if (!readItems.has(potentialPrevFeed.id!)) {
                                nextSelectedFeed = potentialPrevFeed;
                                break;
                            }
                        }
                    }
                    // If still no unread item found (neither next nor previous),
                    // nextSelectedFeed remains null, which will clear the detail panel.
                } else {
                    // If the marked item wasn't found (edge case?), keep selection unless it was the marked one
                    if (selectedFeedDesktop?.id === itemId) {
                        nextSelectedFeed = null;
                    } else {
                        nextSelectedFeed = selectedFeedDesktop; // Keep existing selection
                    }
                }
                selectedFeedDesktop = nextSelectedFeed; // Update selection
            }

            // --- Save read items ---
            try {
                const storableArray = Array.from(readItems.entries());
                localStorage.setItem(
                    READ_ITEMS_STORAGE_KEY,
                    JSON.stringify(storableArray),
                );
            } catch (e) {
                console.error("Failed to save read items to localStorage:", e);
            }
        }
    }

    // NEW: Select feed for desktop detail view
    function selectFeedForDetail(event: MouseEvent, feed: FeedVO) {
        event.preventDefault(); // Prevent default link navigation on desktop
        selectedFeedDesktop = feed;
    }

    // Mobile click handler (unchanged, navigates)
    function handleFeedClickMobile(event: MouseEvent, feed: FeedVO) {
        event.preventDefault();
        const itemId = feed.id!;

        // --- SAVE SCROLL POSITION ---
        if (
            isMobile &&
            typeof window !== "undefined" &&
            typeof sessionStorage !== "undefined"
        ) {
            try {
                sessionStorage.setItem(
                    SCROLL_POSITION_STORAGE_KEY,
                    String(window.scrollY),
                );
                sessionStorage.setItem(NAVIGATING_TO_DETAIL_KEY, "true"); // NEW: Set navigation flag
            } catch (e) {
                console.error(
                    "Failed to save scroll/navigation state to sessionStorage:",
                    e,
                );
            }
        }

        // --- END SAVE SCROLL POSITION ---

        const feedDetailData = {
            title: feed.labels.title || $_("past24h.untitledFeed"),
            summaryHtmlSnippet: feed.labels.summary_html_snippet || "",
            link: feed.labels.link,
            // Add other data if needed
        };

        selectedFeedStore.set(feedDetailData);

        try {
            sessionStorage.setItem(
                "selectedFeedDetail",
                JSON.stringify(feedDetailData),
            );
            sessionStorage.setItem(MARK_ON_MOBILE_KEY, itemId); // Set the key to be read on return
        } catch (e) {
            console.error(
                "Failed to save feed detail/ID to sessionStorage:",
                e,
            );
        }

        goto("/feed-detail");
    }

    // Context menu handler (unchanged)
    function handleMarkAsRead(event: MouseEvent, feed: FeedVO) {
        event.preventDefault();
        markItemRead(feed.id!); // Use pre-calculated ID
    }

    // Custom transition (unchanged)
    function shrinkFadeOut(
        node: HTMLElement,
        { delay = 0, duration = 500, easing = cubicOut },
    ) {
        const style = getComputedStyle(node);
        const originalOpacity = +style.opacity;
        const originalHeight = node.offsetHeight;
        const originalMarginTop = parseFloat(style.marginTop);
        const originalMarginBottom = parseFloat(style.marginBottom);
        const originalPaddingTop = parseFloat(style.paddingTop);
        const originalPaddingBottom = parseFloat(style.paddingBottom);
        const originalTransform =
            style.transform === "none" ? "" : style.transform;

        return {
            delay,
            duration,
            easing,
            css: (t: number, u: number) => `
                opacity: ${u * originalOpacity};
                transform: ${originalTransform} scaleY(${u});
                transform-origin: top;
                height: ${u * originalHeight}px;
                margin-top: ${u * originalMarginTop}px;
                margin-bottom: ${u * originalMarginBottom}px;
                padding-top: ${u * originalPaddingTop}px;
                padding-bottom: ${u * originalPaddingBottom}px;
                overflow: hidden;
                box-shadow: 0px ${u * 4}px ${u * 6}px -${u * 1}px rgba(0, 0, 0, ${u * 0.1}), 0px ${u * 2}px ${u * 4}px -${u * 2}px rgba(0, 0, 0, ${u * 0.1});
            `,
        };
    }

    // --- Lifecycle ---

    onMount(() => {
        // --- Mobile Detection ---
        if (typeof window !== "undefined" && window.matchMedia) {
            const mediaQueryList = window.matchMedia("(max-width: 767px)");
            isMobile = mediaQueryList.matches;
            const updateMobileStatus = (e: MediaQueryListEvent) => {
                const wasMobile = isMobile;
                isMobile = e.matches;
                if (
                    wasMobile &&
                    !isMobile &&
                    typeof sessionStorage !== "undefined"
                ) {
                    sessionStorage.removeItem(SCROLL_POSITION_STORAGE_KEY);
                    shouldRestoreScroll = false;
                }
            };
            mediaQueryList.addEventListener("change", updateMobileStatus);
            onDestroy(() =>
                mediaQueryList.removeEventListener(
                    "change",
                    updateMobileStatus,
                ),
            );
        }

        let cacheHit = false;
        let markItemFromDetailId: string | null = null; // Temporary store for ID to mark

        // --- Check if returning from detail page (Mobile) ---
        if (typeof sessionStorage !== "undefined") {
            const isReturning =
                sessionStorage.getItem(NAVIGATING_TO_DETAIL_KEY) === "true";
            if (isReturning) {
                sessionStorage.removeItem(NAVIGATING_TO_DETAIL_KEY); // Clean up flag

                // Try loading from cache first
                const cachedData = get(queryFeedsStore);
                if (cachedData) {
                    console.log("Loading feeds from cache on return.");
                    searchResults = cachedData; // This triggers reactive updates
                    // updateAvailableLabels(cachedData.feeds); // Labels should be same if cache is valid
                    isLoading = false;
                    cacheHit = true;

                    // Check for scroll restoration (should happen after cache load)
                    const savedScroll = sessionStorage.getItem(
                        SCROLL_POSITION_STORAGE_KEY,
                    );
                    if (savedScroll) {
                        shouldRestoreScroll = true; // Flag for afterUpdate
                    } else {
                        // If returning but no scroll pos, reset to top (or desired behavior)
                        window.scrollTo(0, 0);
                    }

                    // Get the ID to mark read, but don't mark yet (wait for readItems)
                    try {
                        markItemFromDetailId =
                            sessionStorage.getItem(MARK_ON_MOBILE_KEY);
                        if (markItemFromDetailId) {
                            sessionStorage.removeItem(MARK_ON_MOBILE_KEY); // Clean up immediately
                            console.log(
                                "Found item to mark on return (from cache):",
                                markItemFromDetailId,
                            );
                        }
                    } catch (e) {
                        console.error(
                            "Failed access sessionStorage for mark on return (cache path):",
                            e,
                        );
                        markItemFromDetailId = null;
                    }
                } else {
                    console.log(
                        "Returning, but cache is empty. Fetching fresh data.",
                    );
                    // If cache is empty even when returning, proceed to fetch fresh data below
                }
            } else {
                // Not returning from detail view, check for scroll pos from other scenarios if needed
                // (Current logic in fetchFeeds handles this, might be redundant here)
                // const savedScroll = sessionStorage.getItem(SCROLL_POSITION_STORAGE_KEY);
                // if (savedScroll && isMobile) {
                //     shouldRestoreScroll = true;
                // }
            }
        }

        // --- Load Preferences --- (Order matters - load before potentially using defaults in grouping)
        try {
            const savedGroupLabel = localStorage.getItem(
                GROUP_BY_LABEL_STORAGE_KEY,
            );
            if (savedGroupLabel) selectedGroupByLabel = savedGroupLabel;
        } catch (e) {
            console.error("Failed to load group by preference:", e);
        }

        try {
            const savedActiveGroupName = localStorage.getItem(
                ACTIVE_GROUP_NAME_STORAGE_KEY,
            );
            if (savedActiveGroupName)
                initialActiveGroupName = savedActiveGroupName;
        } catch (e) {
            console.error("Failed to load active group name preference:", e);
        }

        // --- Preload audio ---
        markAsReadSound = new Audio("/sounds/woodfish.mp3");
        markAsReadSound.volume = 0.5;
        markAsReadSound.load();

        // --- Load read items --- (Load *after* potential cache load, but *before* marking item)
        try {
            const storedData = localStorage.getItem(READ_ITEMS_STORAGE_KEY);
            if (storedData) {
                const parsedArray = JSON.parse(storedData);
                if (
                    Array.isArray(parsedArray) &&
                    parsedArray.every(
                        (pair) => Array.isArray(pair) && pair.length === 2,
                    )
                ) {
                    readItems = new Map(parsedArray);
                } else {
                    console.warn(
                        "Invalid read items format in localStorage. Clearing.",
                    );
                    localStorage.removeItem(READ_ITEMS_STORAGE_KEY);
                    readItems = new Map();
                }
            } else {
                readItems = new Map();
            }
        } catch (e) {
            console.error("Failed to load/parse read items:", e);
            localStorage.removeItem(READ_ITEMS_STORAGE_KEY);
            readItems = new Map();
        }

        // --- Mark item read from detail page (if applicable and cache was hit) ---
        if (markItemFromDetailId && cacheHit) {
            const idToMark = markItemFromDetailId; // Use local copy
            markItemFromDetailId = null; // Clear temporary variable

            // Use tick to ensure reactive updates from searchResults and readItems have propagated
            tick().then(() => {
                // Ensure readItems map exists and the item ID is present in the feeds from cache
                if (readItems && feedsWithIds.some((f) => f.id === idToMark)) {
                    if (!readItems.has(idToMark)) {
                        // Check if not already marked
                        console.log(
                            "Marking item on return (after cache load):",
                            idToMark,
                        );
                        markItemRead(idToMark);
                    } else {
                        console.log(
                            "Item to mark on return already marked:",
                            idToMark,
                        );
                    }
                } else {
                    console.warn(
                        "Item to mark on return not found in cached feed list or readItems not loaded:",
                        idToMark,
                    );
                }
            });
        }

        // --- Fetch initial data ONLY if cache was not hit ---
        if (!cacheHit) {
            fetchFeeds(); // fetchFeeds now updates the store internally
            // The logic for marking item read on return when fetchFeeds is called
            // needs to remain separate or be handled carefully if needed for non-cache scenarios.
            // Currently, we assume marking is only needed when returning and using cache.
        } else {
            // If cache was hit, ensure labels are processed (might be redundant if searchResults update handles it)
            if (searchResults?.feeds) {
                updateAvailableLabels(searchResults.feeds);
                // Ensure grouping happens by triggering reactivity (might already happen via searchResults)
                feedsWithIds = searchResults.feeds.map((feed) => ({
                    ...feed,
                    id: getFeedItemId(feed),
                }));
                // Trigger readItems filter update explicitly after cache load + readItems load
                readItems = new Map(readItems);
            }
        }
    });

    // --- afterUpdate for scroll restoration --- (Keep as is)
    afterUpdate(() => {
        if (
            shouldRestoreScroll &&
            isMobile &&
            typeof window !== "undefined" &&
            typeof sessionStorage !== "undefined"
        ) {
            const savedScroll = sessionStorage.getItem(
                SCROLL_POSITION_STORAGE_KEY,
            );
            const scrollPosition = parseInt(savedScroll || "0", 10);
            if (!isNaN(scrollPosition) && scrollPosition > 0) {
                Promise.resolve().then(() => {
                    window.scrollTo(0, scrollPosition);
                    console.log("Scroll restored to:", scrollPosition);
                });
            }
            sessionStorage.removeItem(SCROLL_POSITION_STORAGE_KEY);
            shouldRestoreScroll = false;
        }
    });

    // No onDestroy needed for tooltip timeout anymore
</script>

<div
    class="from-base-100 via-base-200/50 to-base-100 min-h-screen space-y-6 bg-gradient-to-br p-4 md:p-8 relative"
>
    <!-- Add Source Button -->
    {#if !disableAddSource}
        <div class="absolute top-4 right-4 md:top-8 md:right-8 z-10">
            <a
                href="/settings/sources"
                class="btn btn-outline btn-primary btn-sm rounded-lg"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="1.5"
                    stroke="currentColor"
                    class="h-4 w-4 mr-1.5"
                    ><path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M12 4.5v15m7.5-7.5h-15"
                    /></svg
                >
                {$_("past24h.addSourceButton")}
            </a>
        </div>
    {/if}

    <!-- Search Section -->
    <div class="flex flex-wrap items-center gap-3">
        <!-- Group By Dropdown -->
        {#if availableGroupByLabels.length > 1 && !isLoading}
            <div class="flex items-center gap-2">
                <span class="text-sm font-medium text-base-content/80"
                    >{$_("past24h.groupByLabel")}:</span
                >
                <div class="dropdown dropdown-end">
                    <div
                        tabindex="0"
                        role="button"
                        class="btn btn-sm btn-outline btn-neutral min-w-[8rem] h-10 justify-between font-normal"
                    >
                        <span class="text-lg text-base-content/80"
                            >{selectedGroupByLabel}</span
                        >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="w-3 h-3 opacity-70"
                            ><path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="m19.5 8.25-7.5 7.5-7.5-7.5"
                            /></svg
                        >
                    </div>
                    <ul
                        tabindex="0"
                        class="dropdown-content z-[1] menu p-2 shadow bg-base-100 rounded-box w-32 mt-1 max-h-60 overflow-y-auto"
                    >
                        {#each availableGroupByLabels as labelKey}
                            <li>
                                <a
                                    href="#"
                                    role="button"
                                    class:active={selectedGroupByLabel ===
                                        labelKey}
                                    on:click|preventDefault={() => {
                                        if (selectedGroupByLabel !== labelKey) {
                                            selectedGroupByLabel = labelKey;
                                            // Save directly on selection
                                            if (
                                                typeof localStorage !==
                                                "undefined"
                                            ) {
                                                try {
                                                    localStorage.setItem(
                                                        GROUP_BY_LABEL_STORAGE_KEY,
                                                        selectedGroupByLabel,
                                                    );
                                                } catch (e) {
                                                    console.error(
                                                        "Failed to save group by preference:",
                                                        e,
                                                    );
                                                }
                                            }
                                            // Optionally reset active tab when group label changes,
                                            // though the main reactive block might handle this implicitly.
                                            // activeGroupName = null; // Might cause flicker, test if needed
                                        }
                                        // Dropdown closes automatically
                                    }}>{labelKey}</a
                                >
                            </li>
                        {/each}
                    </ul>
                </div>
            </div>
        {/if}

        <!-- Centered Search Input and Button -->
        {#if !disableSearchTerm}
            <div class="mx-auto flex flex-1 items-center gap-3">
                <input
                    type="search"
                    placeholder={$_("past24h.searchPlaceholder")}
                    class="input input-bordered input-primary focus:ring-primary focus:border-primary w-full max-w-lg rounded-lg bg-white/90 px-4 py-2.5 text-base focus:ring-2 focus:outline-none"
                    bind:value={searchTerm}
                    on:keydown={handleKeydown}
                    disabled={isLoading}
                />
                <button
                    class="btn btn-primary rounded-lg"
                    on:click={handleSearch}
                    disabled={isLoading}
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke-width="1.5"
                        stroke="currentColor"
                        class="h-5 w-5"
                        ><path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"
                        /></svg
                    >
                    <span class="ml-1.5 hidden sm:inline"
                        >{$_("past24h.searchButton")}</span
                    >
                </button>
                {#if !isLoading && (searchTerm || (searchResults && Object.keys(groupedFeeds).length === 0 && !searchTerm))}
                    <button
                        class="btn btn-ghost rounded-lg"
                        on:click={() => {
                            searchTerm = "";
                            handleSearch();
                        }}
                        title={$_("past24h.backButtonTitle")}
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="h-5 w-5"
                            ><path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3"
                            /></svg
                        >
                        <span class="ml-1.5 hidden sm:inline"
                            >{$_("past24h.backButton")}</span
                        >
                    </button>
                {/if}
            </div>
        {/if}
    </div>

    <!-- Search Summary Section -->
    {#if !isLoading && searchTerm && searchResults && searchResults.summary}
        <div class="card border-primary/40 rounded-lg border shadow-md">
            <div class="card-body p-5">
                <h2 class="card-title text-lg font-medium">
                    {$_("past24h.aiSummaryTitle")}
                </h2>
                <div
                    class="prose prose-sm max-w-none leading-relaxed text-base"
                >
                    {@html summaryHtml}
                </div>
            </div>
        </div>
    {/if}

    <!-- Main Content Area: Conditional Layout -->
    <div class="mt-8 rounded-lg">
        {#if isLoading}
            <div
                class="flex h-full min-h-[350px] items-center justify-center p-10 text-center"
            >
                <div class="flex flex-col items-center">
                    <span
                        class="loading loading-lg loading-spinner text-primary"
                    ></span>
                    <p class="text-primary mt-4 text-lg font-medium">
                        {$_("past24h.loading")}
                    </p>
                </div>
            </div>
        {:else if error}
            <div class="alert alert-error rounded-lg shadow-lg">
                <div class="flex items-center">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="text-error-content h-6 w-6 flex-shrink-0 stroke-current"
                        fill="none"
                        viewBox="0 0 24 24"
                        ><path
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            stroke-width="2"
                            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                        /></svg
                    >
                    <span class="text-error-content ml-2 font-semibold"
                        >{$_("past24h.errorPrefix")}</span
                    >
                    <span class="text-error-content ml-1">{error}</span>
                </div>
            </div>
        {:else if Object.keys(filteredGroupedFeeds).length === 0}
            <!-- Combined Empty State (No Results / All Read) -->
            <div
                class="border-base-300 bg-base-200 flex h-full min-h-[350px] flex-col items-center justify-center rounded-xl border border-dashed p-10 text-center"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke-width="1.5"
                    stroke="currentColor"
                    class="text-primary/60 mb-5 h-16 w-16"
                    aria-hidden="true"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
                    />
                </svg>
                <p class="text-neutral-focus mb-2 text-lg font-semibold">
                    {#if searchTerm}
                        {$_("past24h.emptyStateSearch", {
                            values: { searchTerm: searchTerm },
                        })}
                    {:else if Object.keys(groupedFeeds).length > 0 && Object.keys(filteredGroupedFeeds).length === 0}
                        {$_("past24h.emptyStateAllRead")}
                    {:else}
                        {$_("past24h.emptyStateNoFeeds")}
                    {/if}
                </p>
                <p class="text-neutral/80 mb-6 text-sm">
                    {#if searchTerm}
                        {$_("past24h.emptyStateSearchHint")}
                    {:else if Object.keys(groupedFeeds).length > 0 && Object.keys(filteredGroupedFeeds).length === 0}
                        {$_("past24h.emptyStateAllReadHint")}
                    {:else}
                        {$_("past24h.emptyStateNoFeedsHint")}
                    {/if}
                </p>
            </div>
        {:else}
            <!-- DESKTOP: Two Column Layout (md and up) -->
            <div class="hidden md:flex md:gap-6 lg:gap-8">
                <!-- Left Column: Tabs + Feed List -->
                <div class="md:w-1/3 lg:w-2/5 flex flex-col">
                    <!-- Tabs for Groups -->
                    {#if sortedGroupEntries.length > 1}
                        <div
                            role="tablist"
                            class="tabs tabs-lifted tabs-sm mb-4 -mt-2"
                        >
                            {#each sortedGroupEntries as [groupName, feeds] (groupName)}
                                <button
                                    role="tab"
                                    class="tab [--tab-bg:oklch(var(--b2))] [--tab-border-color:oklch(var(--b3))] [--tab-color:oklch(var(--nc))] font-medium"
                                    class:tab-active={activeGroupName ===
                                        groupName}
                                    class:!text-primary={activeGroupName ===
                                        groupName}
                                    on:click={() => {
                                        if (activeGroupName !== groupName) {
                                            activeGroupName = groupName;
                                            selectedFeedDesktop = null; // Clear selection when changing tabs
                                        }
                                    }}
                                >
                                    <span
                                        class="truncate max-w-[100px] lg:max-w-[150px]"
                                        title={groupName}
                                    >
                                        {groupName}
                                    </span>
                                    <span class="ml-1.5 text-xs opacity-60"
                                        >({feeds.length})</span
                                    >
                                </button>
                            {/each}
                            <!-- Filler tab for style -->
                            <a
                                role="tab"
                                class="tab flex-1 cursor-default [--tab-border-color:oklch(var(--b3))]"
                            ></a>
                        </div>
                    {/if}

                    <!-- Feed List for Active Group -->
                    <div
                        class="flex-1 bg-base-100 border border-base-300 rounded-lg p-3 overflow-y-auto shadow-inner max-h-[65vh]"
                        on:wheel={preventScrollChaining}
                    >
                        {#if activeGroupName && filteredGroupedFeeds[activeGroupName]}
                            <ul class="list-none space-y-1.5 text-sm">
                                {#each filteredGroupedFeeds[activeGroupName] as feed (feed.id)}
                                    <li
                                        class="rounded-md transition-colors duration-150 ease-in-out"
                                        class:bg-base-300={selectedFeedDesktop?.id ===
                                            feed.id}
                                        on:contextmenu={(e) =>
                                            handleMarkAsRead(e, feed)}
                                        out:shrinkFadeOut={{ duration: 400 }}
                                    >
                                        <a
                                            href={feed.labels.link}
                                            class="block p-2 rounded-md hover:bg-base-200 cursor-pointer"
                                            class:font-semibold={selectedFeedDesktop?.id ===
                                                feed.id}
                                            rel="noopener noreferrer"
                                            title={$_("past24h.markAsReadHint")}
                                            on:click={(e) =>
                                                selectFeedForDetail(e, feed)}
                                        >
                                            {#if FEED_TITLE_PREFIX_LABEL && FEED_TITLE_PREFIX_LABEL !== selectedGroupByLabel && feed.labels[FEED_TITLE_PREFIX_LABEL]}
                                                <span class="mr-1 opacity-60"
                                                    >[{feed.labels[
                                                        FEED_TITLE_PREFIX_LABEL
                                                    ]}]</span
                                                >
                                            {/if}
                                            <span
                                                class="break-words line-clamp-2 leading-tight"
                                            >
                                                {feed.labels.title ||
                                                    $_("past24h.untitledFeed")}
                                            </span>
                                        </a>
                                    </li>
                                {/each}
                            </ul>
                        {:else if activeGroupName}
                            <p class="text-center text-neutral-content/60 p-4">
                                {$_("past24h.noItemsInGroup")}
                            </p>
                        {/if}
                    </div>
                </div>

                <!-- Right Column: Selected Feed Detail -->
                <div class="md:w-2/3 lg:w-3/5">
                    <div class="sticky top-8">
                        {#if selectedFeedDesktop}
                            <div
                                class="card bg-base-100 border border-base-300 shadow-lg rounded-xl"
                            >
                                <div class="card-body p-5 lg:p-6">
                                    <h2
                                        class="card-title text-lg lg:text-xl font-semibold mb-3 break-words"
                                    >
                                        {selectedFeedDesktop.labels.title ||
                                            $_("past24h.untitledFeed")}
                                    </h2>
                                    {#if selectedFeedDesktop.labels.link}
                                        <a
                                            href={selectedFeedDesktop.labels
                                                .link}
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            class="link-primary text-xs lg:text-sm mb-4 inline-block truncate max-w-full"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                viewBox="0 0 20 20"
                                                fill="currentColor"
                                                class="w-4 h-4 inline-block mr-1 align-text-bottom opacity-70"
                                                ><path
                                                    fill-rule="evenodd"
                                                    d="M4.25 5.5a.75.75 0 0 0-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 0 0 .75-.75v-4a.75.75 0 0 1 1.5 0v4A2.25 2.25 0 0 1 12.75 17h-8.5A2.25 2.25 0 0 1 2 14.75v-8.5A2.25 2.25 0 0 1 4.25 4h5a.75.75 0 0 1 0 1.5h-5Z"
                                                    clip-rule="evenodd"
                                                /><path
                                                    fill-rule="evenodd"
                                                    d="M6.194 12.753a.75.75 0 0 0 1.06.053L16.5 4.44v2.81a.75.75 0 0 0 1.5 0v-4.5a.75.75 0 0 0-.75-.75h-4.5a.75.75 0 0 0 0 1.5h2.553l-9.056 8.19a.75.75 0 0 0 .053 1.06Z"
                                                    clip-rule="evenodd"
                                                /></svg
                                            >
                                            {$_("past24h.fullArticle")}
                                        </a>
                                    {/if}
                                    <div
                                        bind:this={detailPanelContentElement}
                                        class="prose prose-sm max-w-none leading-relaxed overflow-y-auto max-h-[60vh]"
                                        on:wheel={preventScrollChaining}
                                    >
                                        {@html rightPanelHtml ||
                                            '<p class="italic text-neutral-content/50">' +
                                                $_(
                                                    "past24h.noSummaryAvailable",
                                                ) +
                                                "</p>"}
                                    </div>
                                </div>
                            </div>
                        {:else}
                            <div
                                class="flex flex-col items-center justify-center h-96 border border-dashed border-base-300 rounded-xl bg-base-200/50 text-center p-8"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke-width="1.5"
                                    stroke="currentColor"
                                    class="w-12 h-12 text-neutral-content/40 mb-4"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25V21L12 17.25 15.75 21V14.25h2.25A1.5 1.5 0 0 1 19.5 12.75Z"
                                    />
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        d="M4.5 6.75A2.25 2.25 0 0 1 6.75 4.5h10.5A2.25 2.25 0 0 1 19.5 6.75v10.5A2.25 2.25 0 0 1 17.25 19.5H6.75A2.25 2.25 0 0 1 4.5 17.25V6.75Z M4.5 4.5v.75"
                                    />
                                </svg>

                                <p
                                    class="text-lg font-semibold text-neutral-content/80"
                                >
                                    {$_("past24h.selectFeedPrompt")}
                                </p>
                                <p class="text-sm text-neutral-content/60">
                                    {$_("past24h.selectFeedHint")}
                                </p>
                            </div>
                        {/if}
                    </div>
                </div>
            </div>

            <!-- MOBILE: Card Grid Layout (fallback for md down) -->
            <div class="grid grid-cols-1 gap-6 md:hidden">
                {#each sortedGroupEntries as [groupName, feeds] (groupName)}
                    <div
                        class="card bg-base-100 border-base-300 rounded-xl border shadow-lg transition-all duration-300 hover:shadow-xl"
                    >
                        <div class="card-body p-5">
                            <h2
                                class="card-title mb-3 truncate text-base font-semibold"
                                title={groupName}
                            >
                                {groupName}
                            </h2>
                            <ul
                                class="list-none space-y-2.5 overflow-y-auto pr-1 text-sm"
                                style="max-height: 240px;"
                            >
                                {#each feeds as feed (feed.id)}
                                    <li
                                        class="truncate"
                                        on:contextmenu={(e) =>
                                            handleMarkAsRead(e, feed)}
                                        out:shrinkFadeOut={{ duration: 500 }}
                                        title={feed.labels.title ||
                                            $_("past24h.untitledFeed")}
                                    >
                                        <a
                                            href={feed.labels.link}
                                            rel="noopener noreferrer"
                                            class="text-primary hover:text-secondary break-words hover:underline"
                                            on:click={(e) =>
                                                handleFeedClickMobile(e, feed)}
                                        >
                                            {#if FEED_TITLE_PREFIX_LABEL && FEED_TITLE_PREFIX_LABEL !== selectedGroupByLabel && feed.labels[FEED_TITLE_PREFIX_LABEL]}
                                                <span class="mr-1 opacity-60"
                                                    >[{feed.labels[
                                                        FEED_TITLE_PREFIX_LABEL
                                                    ]}]</span
                                                >
                                            {/if}
                                            {feed.labels.title ||
                                                $_("past24h.untitledFeed")}
                                        </a>
                                    </li>
                                {/each}
                            </ul>
                        </div>
                    </div>
                {/each}
            </div>
        {/if}
    </div>

    <!-- Tooltip Element - REMOVED as right panel replaces it on desktop -->

    <!-- MCP Client Hint -->
    {#if !isLoading && searchTerm && searchResults && searchResults.summary}
        <div class="mt-8 text-center pb-16">
            <p class="text-neutral-content/100 text-sm">
                {@html $_("past24h.mcpHint", {
                    values: {
                        cherryStudioLink: `<a href="https://github.com/glidea/zenfeed/blob/main/docs/cherry-studio-mcp.md" target="_blank" rel="noopener noreferrer" class="link link-secondary">Cherry Studio</a>`,
                    },
                })}
            </p>
        </div>
    {/if}

    <!-- Bottom Center Read Count -->
    {#if todayReadCount > 0}
        <div
            class="fixed bottom-5 left-1/2 transform -translate-x-1/2 z-40 px-4 py-2 rounded-full bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-500 text-white shadow-lg backdrop-blur-sm flex items-center space-x-2 text-sm font-bold transition-all duration-300 ease-out select-none"
            in:fly={{ y: 20, duration: 400, easing: cubicOut }}
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                class="w-5 h-5 opacity-90"
                ><path
                    fill-rule="evenodd"
                    d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm3.857-9.809a.75.75 0 0 0-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 1 0-1.06 1.061l2.5 2.5a.75.75 0 0 0 1.137-.089l4-5.5Z"
                    clip-rule="evenodd"
                /></svg
            >
            <span class="font-normal">{$_("past24h.todayReadPrefix")}</span>
            {#key todayReadCount}
                <span
                    class="inline-block min-w-[1.5ch] text-center text-lg font-extrabold bg-white/20 px-1.5 rounded-md"
                    in:fly={{
                        y: -8,
                        duration: 250,
                        delay: 50,
                        easing: cubicOut,
                    }}
                    out:fly={{ y: 8, duration: 150, easing: cubicOut }}
                >
                    {todayReadCount}
                </span>
            {/key}
            <span class="font-normal">{$_("past24h.todayReadSuffix")}</span>
        </div>
    {/if}
</div>
